{
  "always_run_in_app" : false,
  "icon" : {
    "color" : "deep-gray",
    "glyph" : "hdd"
  },
  "name" : "WebStore",
  "script" : "\/\/ Variables used by Scriptable.\n\/\/ These must be at the very top of the file. Do not edit.\n\/\/ icon-color: teal; icon-glyph: book-open;\n\nlet fm;\ntry {\n  fm = FileManager.iCloud();\n} catch (e) {\n  console.log('设置文件缓存路径失败，请检查 iCloud 权限是否开启');\n  console.error(e);\n  fm = FileManager.local();\n}\nconst RootPath = fm.documentsDirectory();\n\nconst saveFileName = (fileName) => {\n  const hasSuffix = fileName.lastIndexOf('.') + 1;\n  return !hasSuffix ? `${fileName}.js` : fileName;\n};\n\nconst write = (fileName, content, version = '') => {\n  let file = saveFileName(fileName);\n  const filePath = fm.joinPath(RootPath, file);\n  fm.writeString(filePath, `${content}\\n\/\/version:${version}`);\n  return true;\n};\n\nconst saveFile = async ({ moduleName, url, version }) => {\n  const req = new Request(encodeURI(url));\n  const content = await req.loadString();\n  write(`${moduleName}`, content, version);\n  return true;\n};\n\nasync function downloadWidget(widget) {\n  const text = '下载';\n  const a = new Alert();\n  try {\n    await saveFile({\n      moduleName: widget.name,\n      url: widget.scriptURL,\n      version: widget.version,\n    });\n    if (widget.depend) {\n      const depend = JSON.parse(widget.depend);\n      for (const dependElement of depend) {\n        await saveFile({\n          moduleName: dependElement.name,\n          url: dependElement.scriptURL,\n        });\n        console.log(`依赖：${dependElement.name}下载成功`);\n      }\n    }\n    a.message = `组件脚本${widget.title}${text}成功，请在组件列表中找到${widget.name}运行！`;\n  } catch (e) {\n    console.log(e);\n    a.message = `组件脚本${widget.title}${text}失败!`;\n  }\n  a.addCancelAction('确定');\n  await a.presentAlert();\n  return true;\n}\n\nasync function getLocalStoreWidget(widget) {\n  const scriptPath = fm.joinPath(RootPath, `${widget.name}.js`);\n  const scriptExists = fm.fileExists(scriptPath);\n  const alreadyExistsAlert = new Alert();\n  if (scriptExists) {\n    const scriptContent = fm.readString(scriptPath);\n    const m = scriptContent.match(\/version:(.*)\/m);\n    if (m && m[1]) {\n      if (m[1] !== widget.version) {\n        alreadyExistsAlert.message = `检测${widget.title}存在新版本，是否更新？`;\n        alreadyExistsAlert.addAction('更新');\n        alreadyExistsAlert.addCancelAction('取消');\n      } else {\n        alreadyExistsAlert.message = `${widget.title}已经是最新版本，需要继续下载吗？`;\n        alreadyExistsAlert.addAction('确定');\n        alreadyExistsAlert.addCancelAction('取消');\n      }\n    } else {\n      alreadyExistsAlert.message = `确定要安装${widget.title}吗？`;\n      alreadyExistsAlert.addAction('确定');\n      alreadyExistsAlert.addCancelAction('取消');\n    }\n  } else {\n    alreadyExistsAlert.message = `确定要安装${widget.title}吗？`;\n    alreadyExistsAlert.addAction('确定');\n    alreadyExistsAlert.addCancelAction('取消');\n  }\n  if ((await alreadyExistsAlert.presentAlert()) === -1) return false;\n  await downloadWidget(widget);\n}\n\nconst present = async () => {\n  let data = args.queryParameters;\n  if (data.name && data.scriptURL && data.version) {\n    await getLocalStoreWidget(data);\n  } else {\n    const a = new Alert();\n    a.title = data.scriptURL;\n    a.message = '参数存在错误';\n    a.addAction('确定');\n    a.addCancelAction('取消');\n    await a.presentAlert();\n    return false;\n  }\n};\n\nif (config.runsInApp) {\n  await present();\n}\n\nScript.complete();\n\n",
  "share_sheet_inputs" : [

  ]
}