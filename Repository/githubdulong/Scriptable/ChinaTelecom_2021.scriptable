{
  "always_run_in_app" : false,
  "icon" : {
    "color" : "deep-purple",
    "glyph" : "mobile-alt"
  },
  "name" : "ChinaTelecom_2021",
  "script" : "\/\/ Script: 2Ya & 脑瓜\n\/\/ 电报群：https:\/\/t.me\/Scriptable_JS @anker1209\n\/\/ 该脚本小尺寸组件支持两种模式，默认为圆环进度条模式，主屏幕长按小组件-->编辑小组件-->Parameter，输入1，使用文字模式\n\/\/ 渐变进度条为试验性功能，默认关闭\n\/\/ version:1.1.1\n\/\/ update:2022\/10\/20\n\nif (typeof require === 'undefined') require = importModule;\nconst {DmYY, Runing} = require('.\/DmYY');\n\nclass Widget extends DmYY {\n  constructor(arg) {\n    super(arg);\n    this.name = '中国电信';\n    this.en = 'ChinaTelecom_2021';\n    this.logo = 'https:\/\/raw.githubusercontent.com\/anker1209\/icon\/main\/zgdx-big.png';\n    this.smallLogo = 'https:\/\/raw.githubusercontent.com\/anker1209\/icon\/main\/zgdx.png';\n    this.Run();\n  }\n  cookie = ''; \/\/ 推荐使用Boxjs代理缓存，若无请自行手动抓包后在此输入中国电信cookie数据或运行脚本-->账号设置-->手动输入。\n  widgetParam = args.widgetParameter;\n\n  gradient = false;\n  usedFlow = false;\n\n  flowColorHex = 'FF6620';\n  voiceColorHex = '78C100';\n\n  ringStackSize = 61;\n  ringTextSize = 14;\n  feeTextSize = 21;\n  textSize = 13;\n  smallPadding = 16;\n  padding = 10;\n  logoScale = 0.24;\n\n  canvSize = 178;\n  canvWidth = 18;\n  canvRadius = 80;\n\n  format = (str) => {\n    return parseInt(str) >= 10 ? str : `0${str}`;\n  };\n\n  date = new Date();\n  arrUpdateTime = [\n    this.format(this.date.getMonth() + 1),\n    this.format(this.date.getDate()),\n    this.format(this.date.getHours()),\n    this.format(this.date.getMinutes()),\n  ];\n\n  fee = {\n    title: '剩余话费',\n    number: 0,\n    unit: '元',\n    en: '¥',\n  };\n  \n  flow = {\n    percent: 0,\n    max: 40,\n    title: '剩余流量',\n    number: 0,\n    unit: 'MB',\n    en: 'MB',\n    icon: 'antenna.radiowaves.left.and.right',\n    iconColor: new Color('1ab6f8'),\n    FGColor: new Color(this.flowColorHex),\n    BGColor: new Color(this.flowColorHex, 0.2),\n    colors: [],\n  };\n\n  voice = {\n    percent: 0,\n    title: '剩余语音',\n    number: 0,\n    unit: '分钟',\n    en: 'MIN',\n    icon: 'phone.fill',\n    iconColor: new Color('30d15b'),\n    FGColor: new Color(this.voiceColorHex),\n    BGColor: new Color(this.voiceColorHex, 0.2),\n    colors: [],\n  };\n  \n  point = {\n    title: '更新时间',\n    number: `${this.arrUpdateTime[2]}:${this.arrUpdateTime[3]}`,\n    unit: '',\n    icon: 'arrow.2.circlepath',\n    iconColor: new Color('fc6d6d'),\n  }\n\n  options = {\n    headers: {\n      cookie: '',\n    },\n    method: 'POST',\n  };\n\n  fetchUrl = {\n    detail: 'https:\/\/e.189.cn\/store\/user\/package_detail.do',\n    balance: 'https:\/\/e.189.cn\/store\/user\/balance_new.do',\n  };\n\n  init = async () => {\n    try {\n      await this.getData();\n    } catch (e) {\n      console.log(e);\n    }\n  };\n\n  formatFlow(number) {\n    const n = number \/ 1024;\n    if (n < 1024) {\n      return {count: n.toFixed(2), unit: 'MB'};\n    }\n    return {count: (n \/ 1024).toFixed(2), unit: 'GB'};\n  }\n\n  unlimitUser(flow) {\n    const usedFlow = this.formatFlow(flow);\n    this.flow.title = '已用流量';\n    this.flow.number = usedFlow.count;\n    this.flow.unit = usedFlow.unit;\n    this.flow.en = usedFlow.unit;\n    if (this.flow.unit === 'GB') {\n      this.flow.percent = (100 - (this.flow.number \/ (this.flow.max || 40)) * 100).toFixed(2);\n    } else {\n      this.flow.percent = (100 - (this.flow.number \/ ((this.flow.max || 40) * 1024)) * 100).toFixed(2);\n    }\n  }\n\n  getData = async () => {\n    const detail = await this.http({\n      url: this.fetchUrl.detail,\n      ...this.options,\n    });\n    console.log(detail);\n    const balance = await this.http({\n      url: this.fetchUrl.balance,\n      ...this.options,\n    });\n\n    if (detail.result === 0) {\n      \/\/ 套餐分钟数\n      if (detail.voiceBalance && detail.voiceAmount) {\n        this.voice.percent = ((Number(detail.voiceBalance) \/ Number(detail.voiceAmount)) * 100).toFixed(2);\n        this.voice.number = detail.voiceBalance;\n      } else {\n        detail.items.forEach((data) => {\n          if (data.offerType == 21) {\n            data.items.forEach((item) => {\n              if (item.unitTypeId === '1') {\n                if (item.ratableAmount !== '0' && item.balanceAmount !== '0') {\n                  this.voice.percent = ((Number(item.balanceAmount) \/ Number(item.ratableAmount)) * 100).toFixed(2);\n                  this.voice.number = item.balanceAmount;\n                }\n              }\n            });\n          }\n        });\n      }\n      if (!detail.number && !detail.total) {\n        detail.items.forEach((data) => {\n          if (data.offerType !== 19) {\n            data.items.forEach((item) => {\n              if (item.unitTypeId === '3') {\n                if (item.usageAmount !== '0' && item.balanceAmount !== '0') {\n                  this.flow.percent = ((item.balanceAmount \/ (item.ratableAmount || 1)) * 100).toFixed(2);\n                  const flow = this.formatFlow(item.balanceAmount);\n                  this.flow.number = flow.count;\n                  this.flow.unit = flow.unit;\n                  this.flow.en = flow.unit;\n                }\n                if (data.offerType == 21 && item.ratableAmount == '0') {\n                  this.unlimitUser(item.usageAmount);\n                }\n              }\n            });\n          }\n        });\n      } else {\n        if (this.usedFlow) {\n          this.unlimitUser(detail.used);\n        } else {\n          this.flow.percent = ((detail.balance \/ (detail.total || 1)) * 100).toFixed(2);\n          const flow = this.formatFlow(detail.balance);\n          this.flow.number = flow.count;\n          this.flow.unit = flow.unit;\n          this.flow.en = flow.unit;\n        }\n      }\n\n    }\n    if (balance.result === 0) {\n      \/\/ 余额\n      this.fee.number = parseFloat(parseInt(balance.totalBalanceAvailable) \/ 100).toFixed(2)};\n  };\n\n  async smallHeader(stack) {\n    const headerStack = stack.addStack();\n    headerStack.addSpacer();\n    const logoImage = await this.$request.get(this.logo, 'IMG');\n    const logo = headerStack.addImage(logoImage);\n    logo.imageSize = new Size(455 * this.logoScale, 125 * this.logoScale);\n    logo.tintColor = Color.blue(); \/\/修改颜色\n    headerStack.addSpacer();\n    stack.addSpacer();\n\n    const feeStack = stack.addStack();\n    feeStack.centerAlignContent();\n    feeStack.addSpacer();\n    const feeValue = feeStack.addText(\"¥\"+`${this.fee.number}`);\n    feeValue.font = Font.mediumRoundedSystemFont(this.feeTextSize);\n    feeValue.textColor = this.widgetColor;\n    feeStack.addSpacer();\n    stack.addSpacer();\n  }\n\n  textLayout(stack, data) {\n    const rowStack = stack.addStack();\n    rowStack.centerAlignContent();\n    const icon = SFSymbol.named(data.icon);\n    icon.applyHeavyWeight();\n    let iconElement = rowStack.addImage(icon.image);\n    iconElement.imageSize = new Size(this.textSize, this.textSize);\n    iconElement.tintColor = data.iconColor;\n    rowStack.addSpacer(4);\n    let title = rowStack.addText(data.title);\n    rowStack.addSpacer();\n    let number = rowStack.addText(data.number + data.unit);\n    ;[title, number].map(t => t.textColor = this.widgetColor);\n    ;[title, number].map(t => t.font = Font.systemFont(this.textSize));\n  }\n\n  async mediumCell(canvas, stack, data, color, fee = false, percent) {\n    const bg = new LinearGradient()\n    bg.locations = [0, 1]\n    bg.colors = [\n    new Color(color, 0.03),\n    new Color(color, 0.1)\n    ]\n    const dataStack = stack.addStack();\n    dataStack.backgroundGradient = bg;\n    dataStack.cornerRadius = 20;\n    dataStack.layoutVertically();\n    dataStack.addSpacer();\n\n    const topStack = dataStack.addStack();\n    topStack.addSpacer();\n    await this.imageCell(canvas, topStack, data, fee, percent);\n    topStack.addSpacer();\n\n    if (fee) {\n      dataStack.addSpacer(10);\n      const updateStack = dataStack.addStack();\n      updateStack.addSpacer();\n      updateStack.centerAlignContent();\n      const updataIcon = SFSymbol.named('arrow.2.circlepath');\n      updataIcon.applyHeavyWeight();\n      const updateImg = updateStack.addImage(updataIcon.image);\n      updateImg.tintColor = new Color(color, 0.6);\n      updateImg.imageSize = new Size(10, 10);\n      updateStack.addSpacer(3);\n      const updateText = updateStack.addText(`${this.arrUpdateTime[2]}:${this.arrUpdateTime[3]}`)\n      updateText.font = Font.mediumSystemFont(10);\n      updateText.textColor = new Color(color, 0.6);\n      updateStack.addSpacer();\n    }\n    \n    dataStack.addSpacer();\n\n    const numberStack = dataStack.addStack();\n    numberStack.addSpacer();\n    const number = numberStack.addText(`${data.number} ${data.en}`);\n    number.font = Font.semiboldSystemFont(15);\n    numberStack.addSpacer();\n\n    dataStack.addSpacer(3);\n\n    const titleStack = dataStack.addStack();\n    titleStack.addSpacer();\n    const title = titleStack.addText(data.title);\n    title.font = Font.mediumSystemFont(11);\n    title.textOpacity = 0.7;\n    titleStack.addSpacer();\n\n    dataStack.addSpacer(15);\n    ;[title, number].map(t => t.textColor = new Color(color));\n  }\n\n  async imageCell(canvas, stack, data, fee, percent) {\n    const canvaStack = stack.addStack();\n    canvaStack.layoutVertically();\n    if (!fee) {\n      this.drawArc(canvas, data.percent * 3.6, data.FGColor, data.BGColor);\n      canvaStack.size = new Size(this.ringStackSize, this.ringStackSize);\n      canvaStack.backgroundImage = canvas.getImage();\n      this.ringContent(canvaStack, data, percent);\n    } else {\n      canvaStack.addSpacer(10);\n      const smallLogo = await this.$request.get(this.smallLogo, 'IMG');\n      const logoStack = canvaStack.addStack();\n      logoStack.size = new Size(30, 30);\n      logoStack.backgroundImage = smallLogo;\n    }\n  }\n\n  ringContent(stack, data, percent = false) {\n    const rowIcon = stack.addStack();\n    rowIcon.addSpacer();\n    const icon = SFSymbol.named(data.icon);\n    icon.applyHeavyWeight();\n    const iconElement = rowIcon.addImage(icon.image);\n    iconElement.tintColor = this.gradient ? new Color(data.colors[1]) : data.FGColor;\n    iconElement.imageSize = new Size(12, 12);\n    iconElement.imageOpacity = 0.7;\n    rowIcon.addSpacer();\n\n    stack.addSpacer(1);\n\n    const rowNumber = stack.addStack();\n    rowNumber.addSpacer();\n    const number = rowNumber.addText(percent ? `${data.percent}` : `${data.number}`);\n    number.font = percent ? Font.systemFont(this.ringTextSize - 2) : Font.mediumSystemFont(this.ringTextSize);\n    rowNumber.addSpacer();\n\n    const rowUnit = stack.addStack();\n    rowUnit.addSpacer();\n    const unit = rowUnit.addText(percent ? '%' : data.unit);\n    unit.font = Font.boldSystemFont(8);\n    unit.textOpacity = 0.5;\n    rowUnit.addSpacer();\n\n    if (percent) {\n      if (this.gradient) {\n        ;[unit, number].map(t => t.textColor = new Color(data.colors[1]));\n      } else {\n        ;[unit, number].map(t => t.textColor = data.FGColor);\n      }\n    } else {\n      ;[unit, number].map(t => t.textColor = this.widgetColor);\n    }\n  }\n\n  makeCanvas() {\n    const canvas = new DrawContext();\n    canvas.opaque = false;\n    canvas.respectScreenScale = true;\n    canvas.size = new Size(this.canvSize, this.canvSize);\n    return canvas;\n  }\n\n  sinDeg(deg) {\n    return Math.sin((deg * Math.PI) \/ 180);\n  }\n\n  cosDeg(deg) {\n    return Math.cos((deg * Math.PI) \/ 180);\n  }\n\n  drawArc(canvas, deg, fillColor, strokeColor) {\n    let ctr = new Point(this.canvSize \/ 2, this.canvSize \/ 2);\n    let bgx = ctr.x - this.canvRadius;\n    let bgy = ctr.y - this.canvRadius;\n    let bgd = 2 * this.canvRadius;\n    let bgr = new Rect(bgx, bgy, bgd, bgd)\n\n    canvas.setStrokeColor(strokeColor);\n    canvas.setLineWidth(this.canvWidth);\n    canvas.strokeEllipse(bgr);\n\n    for (let t = 0; t < deg; t++) {\n      let rect_x = ctr.x + this.canvRadius * this.sinDeg(t) - this.canvWidth \/ 2;\n      let rect_y = ctr.y - this.canvRadius * this.cosDeg(t) - this.canvWidth \/ 2;\n      let rect_r = new Rect(rect_x, rect_y, this.canvWidth, this.canvWidth);\n\n      canvas.setFillColor(this.gradient ? new Color(fillColor[t]) : fillColor);\n      canvas.setStrokeColor(strokeColor)\n      canvas.fillEllipse(rect_r);\n    }\n  }\n\n  arrColor() {\n    let colorArr = [['#FFF000', '#E62490'], ['#FDEB71', '#F8D800'], ['#ABDCFF', '#0396FF'], ['#FEB692', '#EA5455'], ['#FEB692', '#EA5455'], ['#CE9FFC', '#7367F0'], ['#90F7EC', '#32CCBC'], ['#FFF6B7', '#F6416C'], ['#E2B0FF', '#9F44D3'], ['#F97794', '#F072B6'], ['#FCCF31', '#F55555'], ['#5EFCE8', '#736EFE'], ['#FAD7A1', '#E96D71'], ['#FFFF1C', '#00C3FF'], ['#FEC163', '#DE4313'], ['#F6CEEC', '#D939CD'], ['#FDD819', '#E80505'], ['#FFF3B0', '#CA26FF'], ['#2AFADF', '#4C83FF'], ['#EECDA3', '#EF629F'], ['#C2E59C', '#64B3F4'], ['#FFF886', '#F072B6'], ['#F5CBFF', '#C346C2'], ['#FFF720', '#3CD500'], ['#EE9AE5', '#5961F9'], ['#FFC371', '#FF5F6D'], ['#FFD3A5', '#FD6585'], ['#C2FFD8', '#465EFB'], ['#FFC600', '#FD6E6A'], ['#FFC600', '#FD6E6A'], ['#92FE9D', '#00C9FF'], ['#FFDDE1', '#EE9CA7'], ['#F0FF00', '#58CFFB'], ['#FFE985', '#FA742B'], ['#72EDF2', '#5151E5'], ['#F6D242', '#FF52E5'], ['#F9D423', '#FF4E50'], ['#3C8CE7', '#00EAFF'], ['#FCFF00', '#FFA8A8'], ['#FF96F9', '#C32BAC'], ['#D0E6A5', '#FFDD94'], ['#FFDD94', '#FA897B'], ['#FFCC4B', '#FF7D58'], ['#D0E6A5', '#86E3CE'], ['#F0D5B6', '#F16238'], ['#F8EC70', '#F9C708'], ['#C4E86B', '#00BCB4'], ['#FFC446', '#FA0874'], ['#E1EE32', '#FFB547'], ['#FFD804', '#2ACCC8'], ['#E9A6D2', '#E9037B'], ['#F8EC70', '#49E2F6'], ['#A2F8CD', '#A2F852'], ['#49E2F6', '#A2F8CD'], ['#FDEFE2', '#FE214F'], ['#F8EC70', '#A2F8CD'], ['#F8EC70', '#49E2F6'], ['#B7FFE4', '#E4B7FF'], ['#FFB7D1', '#E4B7FF'], ['#D0E6A5', '#86E3CE'], ['#E8E965', '#64C5C7']];\n    let colors = colorArr[Math.floor(Math.random() * colorArr.length)];\n    return colors;\n  }\n\n  gradientColor(colors, step) {\n    var startRGB = this.colorToRgb(colors[0]),\n    startR = startRGB[0],\n    startG = startRGB[1],\n    startB = startRGB[2];\n\n    var endRGB = this.colorToRgb(colors[1]),\n    endR = endRGB[0],\n    endG = endRGB[1],\n    endB = endRGB[2];\n\n    var sR = (endR - startR) \/ step,\n    sG = (endG - startG) \/ step,\n    sB = (endB - startB) \/ step;\n\n    var colorArr = [];\n    for (var i = 0;i < step; i++) {\n     var hex = this.colorToHex('rgb(' + parseInt((sR * i + startR)) + ',' + parseInt((sG * i + startG)) + ',' + parseInt((sB * i + startB)) + ')');\n     colorArr.push(hex);\n   }\n   return colorArr;\n }\n\n colorToRgb(sColor) {\n   var reg = \/^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$\/;\n   var sColor = sColor.toLowerCase();\n   if (sColor && reg.test(sColor)) {\n     if (sColor.length === 4) {\n       var sColorNew = \"#\";\n       for (var i = 1; i < 4; i += 1) {\n         sColorNew += sColor.slice(i, i + 1).concat(sColor.slice(i, i + 1));\n       }\n       sColor = sColorNew;\n     }\n     var sColorChange = [];\n     for (var i = 1; i < 7; i += 2) {\n       sColorChange.push(parseInt(\"0x\" + sColor.slice(i, i + 2)));\n     }\n     return sColorChange;\n   } else {\n     return sColor;\n   }\n };\n\n colorToHex(rgb) {\n   var _this = rgb;\n   var reg = \/^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$\/;\n   if (\/^(rgb|RGB)\/.test(_this)) {\n     var aColor = _this.replace(\/(?:\\(|\\)|rgb|RGB)*\/g,\"\").split(\",\");\n     var strHex = \"#\";\n     for (var i = 0; i < aColor.length; i++) {\n       var hex = Number(aColor[i]).toString(16);\n       hex = hex.length < 2 ? 0 + '' + hex : hex;\n       if (hex === \"0\") {\n         hex += hex;\n       }\n       strHex += hex;\n     }\n     if (strHex.length !== 7) {\n       strHex = _this;\n     }\n\n     return strHex;\n   } else if (reg.test(_this)) {\n     var aNum = _this.replace(\/#\/,\"\").split(\"\");\n     if (aNum.length === 6) {\n       return _this;\n     } else if (aNum.length === 3) {\n       var numHex = \"#\";\n       for (var i = 0; i < aNum.length; i+=1) {\n         numHex += (aNum[i] + aNum[i]);\n       }\n       return numHex;\n     }\n   } else {\n     return _this;\n   }\n }\n\n  renderSmall = async (w) => {\n    w.setPadding(this.smallPadding, this.smallPadding, this.smallPadding, this.smallPadding);\n    await this.smallHeader(w);\n    const bodyStack = w.addStack();\n    bodyStack.layoutVertically();\n    if (this.widgetParam == \"1\"){\n      this.textLayout(bodyStack, this.flow);\n      bodyStack.addSpacer(7);\n      this.textLayout(bodyStack, this.voice);\n      bodyStack.addSpacer(7);\n      this.textLayout(bodyStack, this.point);\n    } else {\n      const canvas = this.makeCanvas();\n      const ringStack = bodyStack.addStack();\n      this.imageCell(canvas, ringStack, this.flow);\n      ringStack.addSpacer();\n      this.imageCell(canvas, ringStack, this.voice);\n    }\n    return w;\n  };\n\n  renderMedium = async (w) => {\n    w.setPadding(this.padding, this.padding, this.padding, this.padding);\n    const canvas = this.makeCanvas();\n    const bodyStack = w.addStack();\n    await this.mediumCell(canvas, bodyStack, this.fee, '0A4B9D', true);\n    bodyStack.addSpacer(this.padding);\n    await this.mediumCell(canvas, bodyStack, this.flow, this.flowColorHex, false, true);\n    bodyStack.addSpacer(this.padding);\n    await this.mediumCell(canvas, bodyStack, this.voice, this.voiceColorHex, false,true);\n    return w;\n  };\n\n  renderLarge = async (w) => {\n    w.addText('暂不支持')\n    return w;\n  };\n\n  renderWebView = async () => {\n    const webView = new WebView();\n    const url = 'https:\/\/e.189.cn\/index.do';\n    await webView.loadURL(url);\n    await webView.present(false);\n\n    const request = new Request(this.fetchUrl.detail);\n    request.method = 'POST';\n    const response = await request.loadJSON();\n    console.log(response);\n    if (response.result === -10001) {\n      const index = await this.generateAlert('未获取到用户信息', [\n        '取消',\n        '重试',\n      ]);\n      if (index === 0) return;\n      await this.renderWebView();\n    } else {\n      const cookies = request.response.cookies;\n      let cookie = [];\n      cookie = cookies.map((item) => `${item.name}=${item.value}`);\n      cookie = cookie.join('; ');\n      this.settings.cookie = cookie;\n      this.saveSettings();\n    }\n  };\n\n  Run() {\n    if (config.runsInApp) {\n      const widgetInitConfig = {cookie: 'china_telecom_cookie'};\n      this.registerAction('颜色配置', async () => {\n        await this.setAlertInput(\n          `${this.name}颜色配置`,\n          '进度条颜色|底圈颜色\\n底圈颜色留空将跟随进度条颜色并淡显',\n          {\n            gradient: '是否开启渐变进度条，缺省：false',\n            step1: '流量进度条颜色',\n            step2: '语音进度条颜色',\n            inner1: '流量进度条底圈颜色',\n            inner2: '语音进度条底圈颜色',\n          },\n          );\n      }, 'https:\/\/pic1.imgdb.cn\/item\/63315c1e16f2c2beb1a27363.png');\n      this.registerAction('尺寸设置', async () => {\n        await this.setAlertInput(\n          `${this.name}尺寸设置`,\n          '进度条大小|文字大小',\n          {\n            logoScale: '小组件logo缩放，缺省：0.24',\n            ringStackSize: '圆环大小，缺省：61',\n            ringTextSize: '圆环中心文字大小，缺省：14',\n            feeTextSize: '话费文字大小，缺省：21',\n            textSize: '文字模式下文字大小，缺省：13',\n            smallPadding: '小尺寸组件边距，缺省：16',\n            padding: '中尺寸组件边距，缺省：10',\n          },\n          );\n      }, 'https:\/\/pic1.imgdb.cn\/item\/63315c2c16f2c2beb1a28726.png');\n      this.registerAction('流量设置', async () => {\n        await this.setAlertInput(\n          `${this.name}流量设置`,\n          '是否显示已用流量\\n不限量或伪不限量用户可将此值设为true',\n          {\n            usedFlow: '是否显示已用流量，缺省：false',\n            maxFlow: '实际流量或超限流量(GB)，缺省：40',\n          },\n          );\n      }, 'https:\/\/pic1.imgdb.cn\/item\/63315c2216f2c2beb1a27888.png');\n      this.registerAction(\"账号设置\", async () => {\n        const index = await this.generateAlert(\"设置账号信息\", [\n          \"网站登录\",\n          \"手动输入\",\n        ]);\n        if (index === 0) {\n          await this.renderWebView();\n        } else {\n          await this.setAlertInput(\"账号设置\", \"中国电信 cookie\", {\n            cookie: 'cookie',\n          });\n        }\n      }, 'https:\/\/raw.githubusercontent.com\/githubdulong\/Script\/master\/Images\/account.png');\n      this.registerAction('代理缓存', async () => {\n        await this.setCacheBoxJSData(widgetInitConfig);\n      }, 'https:\/\/raw.githubusercontent.com\/githubdulong\/Script\/master\/Images\/boxjs.png');\n      this.registerAction('基础设置', this.setWidgetConfig, 'https:\/\/raw.githubusercontent.com\/githubdulong\/Script\/master\/Images\/preferences.png');\n    }\n\n    try {\n      const {\n        cookie,\n        step1,\n        step2,\n        inner1,\n        inner2,\n        logoScale,\n        ringStackSize,\n        ringTextSize,\n        feeTextSize,\n        textSize,\n        smallPadding,\n        padding,\n        gradient,\n        usedFlow,\n        maxFlow,\n      } = this.settings;\n      this.cookie = cookie ? cookie : this.cookie;\n      if (this.cookie) this.options.headers.cookie = this.cookie;\n      this.gradient = gradient === 'true' ? true : this.gradient;\n      this.usedFlow = usedFlow === 'true' ? true : this.usedFlow;\n      this.flowColorHex = step1 ? step1 : this.flowColorHex;\n      this.voiceColorHex = step2 ? step2 : this.voiceColorHex;\n      this.flow.BGColor = inner1 ? new Color(inner1) : new Color(this.flowColorHex, 0.2);\n      this.voice.BGColor = inner2 ? new Color(inner2) : new Color(this.voiceColorHex, 0.2);\n      this.flow.FGColor = new Color(this.flowColorHex);\n      this.voice.FGColor = new Color(this.voiceColorHex);\n\n      this.flow.max = maxFlow ? parseFloat(maxFlow) : this.flow.max;\n      this.logoScale = logoScale ? parseFloat(logoScale) : this.logoScale;\n      this.ringStackSize = ringStackSize ? parseFloat(ringStackSize) : this.ringStackSize;\n      this.ringTextSize = ringTextSize ? parseFloat(ringTextSize) : this.ringTextSize;\n      this.feeTextSize = feeTextSize ? parseFloat(feeTextSize) : this.feeTextSize;\n      this.textSize = textSize ? parseFloat(textSize) : this.textSize;\n      this.smallPadding = smallPadding ? parseFloat(smallPadding) : this.smallPadding;\n      this.padding = padding ? parseFloat(padding) : this.padding;\n\n      if (this.gradient) {\n        this.flow.colors = this.arrColor();\n        this.voice.colors = this.arrColor();\n        this.flow.BGColor = inner1 ? new Color(inner1) : new Color(this.flow.colors[1], 0.2);\n        this.voice.BGColor = inner2 ? new Color(inner2) : new Color(this.voice.colors[1], 0.2);\n        this.flow.FGColor = this.gradientColor(this.flow.colors, 360);\n        this.voice.FGColor = this.gradientColor(this.voice.colors, 360);\n        this.flowColorHex = this.flow.colors[1];\n        this.voiceColorHex = this.voice.colors[1];\n      }\n\n    } catch (e) {\n      console.log(e);\n    }\n  }\n\n  async render() {\n    await this.init();\n    const widget = new ListWidget();\n    await this.getWidgetBackgroundImage(widget);\n    if (this.widgetFamily === 'medium') {\n      return await this.renderMedium(widget);\n    } else if (this.widgetFamily === 'large') {\n      return await this.renderLarge(widget);\n    } else {\n      return await this.renderSmall(widget);\n    }\n  }\n}\n\nawait Runing(Widget, args.widgetParameter, false);\n\n\/\/version:1.1.0",
  "share_sheet_inputs" : [

  ]
}